#!/usr/bin/env python3
"""
Recursive Verilog Flattener

Recursively processes Verilog files, flattens them using Yosys,
and preserves directory structure.

Usage:
    python recursive_verilog_flattener.py <input_dir> <output_dir>
"""

import os
import sys
import re
import shutil
import subprocess
from pathlib import Path
from tqdm import tqdm
import multiprocessing as mp

def flatten_with_yosys(input_file, output_file):
    """Flatten Verilog using Yosys. Returns True if successful."""
    script = f"""
read_verilog {input_file}
hierarchy -check -auto-top
flatten
synth -flatten
techmap
opt_clean
write_verilog -noattr -noexpr {output_file}
"""
    
    script_file = output_file + ".ys"
    
    try:
        with open(script_file, 'w') as f:
            f.write(script)
        
        result = subprocess.run(
            ['yosys', '-s', script_file],
            capture_output=True,
            text=True,
            timeout=300
        )
        
        if result.returncode == 0 and os.path.exists(output_file):
            # Validate and clean output
            with open(output_file, 'r') as f:
                content = f.read()
            
            # Remove Yosys header
            if content.startswith('/* Generated by Yosys'):
                end = content.find('*/')
                if end != -1:
                    content = content[end + 2:].lstrip()
            
            # Check if file has actual module (not just comments/empty)
            test = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
            test = re.sub(r'//.*?$', '', test, flags=re.MULTILINE)
            test = test.strip()
            
            if not test or 'module' not in test:
                # Empty file - delete and fail
                if os.path.exists(output_file):
                    os.remove(output_file)
                if os.path.exists(script_file):
                    os.remove(script_file)
                return False
            
            # Write cleaned content
            with open(output_file, 'w') as f:
                f.write(content)
            
            if os.path.exists(script_file):
                os.remove(script_file)
            return True
        else:
            if os.path.exists(script_file):
                os.remove(script_file)
            return False
            
    except (FileNotFoundError, subprocess.TimeoutExpired, Exception):
        if os.path.exists(script_file):
            os.remove(script_file)
        return False


def find_verilog_files(root_dir):
    """Find ALL .v files recursively (no filtering)."""
    verilog_files = []
    root_path = Path(root_dir).resolve()
    
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            if filename.endswith(('.v', '.verilog', '.sv')):
                abs_path = Path(dirpath) / filename
                rel_path = abs_path.relative_to(root_path)
                verilog_files.append((str(rel_path), str(abs_path)))
    
    return sorted(verilog_files)


def process_single_file(args):
    """Worker function for parallel processing."""
    rel_path, input_path, output_dir, method = args
    
    output_path = Path(output_dir) / rel_path
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    if method == 'yosys':
        success = flatten_with_yosys(input_path, str(output_path))
    elif method == 'copy':
        shutil.copy2(input_path, str(output_path))
        success = True
    else:
        success = False
    
    return (rel_path, success)


def flatten_directory_tree(input_dir, output_dir, method='yosys', num_workers=None):
    """Main function to recursively flatten Verilog files."""
    
    print("=" * 80)
    print("RECURSIVE VERILOG FLATTENER")
    print("=" * 80)
    print(f"Input:  {input_dir}")
    print(f"Output: {output_dir}")
    print(f"Method: {method}")
    print("=" * 80)
    
    print("\nüîç Scanning directory tree...")
    verilog_files = find_verilog_files(input_dir)
    
    if not verilog_files:
        print(f"‚ùå No Verilog files found in {input_dir}")
        return
    
    print(f"‚úÖ Found {len(verilog_files)} Verilog files\n")
    
    os.makedirs(output_dir, exist_ok=True)
    
    if num_workers is None:
        num_workers = min(os.cpu_count() or 4, 8)
    
    print(f"üöÄ Processing with {num_workers} parallel workers...\n")
    
    tasks = [(rel, abs_path, output_dir, method) 
             for rel, abs_path in verilog_files]
    
    successful = 0
    failed = 0
    failed_files = []
    
    try:
        mp.set_start_method('spawn', force=True)
    except:
        pass
    
    with mp.Pool(processes=num_workers) as pool:
        for rel_path, success in tqdm(
            pool.imap_unordered(process_single_file, tasks),
            total=len(tasks),
            desc="Flattening files"
        ):
            if success:
                successful += 1
            else:
                failed += 1
                failed_files.append(rel_path)
    
    print("\n" + "=" * 80)
    print("SUMMARY")
    print("=" * 80)
    print(f"Total files:      {len(verilog_files)}")
    print(f"‚úÖ Successful:    {successful}")
    print(f"‚ùå Failed:        {failed}")
    print(f"Success rate:     {successful/len(verilog_files)*100:.1f}%")
    print("=" * 80)
    
    if failed > 0:
        print(f"\n‚ö†Ô∏è  {failed} files failed (likely include/header files)")
        print("First 10 failed files:")
        for f in failed_files[:10]:
            print(f"  - {f}")
        if len(failed_files) > 10:
            print(f"  ... and {len(failed_files) - 10} more")
        print("\nThis is normal for benchmark repositories.")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Recursively flatten Verilog files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python recursive_verilog_flattener.py ./input ./output
  python recursive_verilog_flattener.py ./input ./output --workers 16
  python recursive_verilog_flattener.py ./input ./output --method copy
        """
    )
    
    parser.add_argument('input_dir', help='Input directory')
    parser.add_argument('output_dir', help='Output directory')
    parser.add_argument('--method', choices=['yosys', 'copy'], 
                       default='yosys', help='Method (default: yosys)')
    parser.add_argument('--workers', type=int, default=None,
                       help='Parallel workers (default: auto)')
    
    args = parser.parse_args()
    
    if not os.path.isdir(args.input_dir):
        print(f"‚ùå Error: {args.input_dir} does not exist")
        sys.exit(1)
    
    flatten_directory_tree(
        args.input_dir,
        args.output_dir,
        method=args.method,
        num_workers=args.workers
    )


if __name__ == "__main__":
    main()